import numpy as np
import pandas as pd
import re
import gzip
from random import sample
import math
import random
from collections import defaultdict
import glob, os, sys
import networkx as nx
from sklearn import svm
from sklearn.model_selection import train_test_split
import scipy
import json
from sklearn.metrics import confusion_matrix
from sklearn.metrics import fbeta_score
from sklearn.manifold import TSNE
import matplotlib.pyplot as plt

# APP1 ---> API1 ---> API2 ---> APP2
def APP_to_API_ABA(API, APP, apk2idx, node2apk, A, B, p, q):
    """
    Generate next API based on the current APP and previous API
    """
    APP_idx = apk2idx[node2apk[APP]]
    ser = pd.Series(A[APP_idx].toarray()[0])
    A_neibors = ser[ser == 1].index
    if len(A_neibors) == 0:
        return None
    probs = [1 if B[n, API] else 1/q for n in A_neibors]
    probs[list(A_neibors).index(API)] = 1/p
    p_sum = sum(probs)
    probs = [p/p_sum for p in probs]
    API = np.random.choice(A_neibors, 1, p = probs).item()
    return API

def API_to_API_ABA(APP, API, apk2idx, node2apk, A, B, p, q):
    """
    Generate next API based on the current API and previous APP
    """
    APP_idx = apk2idx[node2apk[APP]]
    ser = pd.Series(B[APP_idx].toarray()[0])
    B_neibors = ser[ser == 1].index
    if len(B_neibors) == 0:
        return None
    probs = [1 if A.T[n, APP_idx] else 1/q for n in B_neibors]
    p_sum = sum(probs)
    probs = [p/p_sum for p in probs]
    return np.random.choice(B_neibors, 1, p = probs).item()

def API_to_APP_ABA(API_pre, API, idx2apk, apk2node, A, p, q):
    """
    Generate next APP based on the current API and previous API
    """
    ser = pd.Series(A.T[API].toarray()[0])
    A_neibors = ser[ser == 1].index
    if len(A_neibors) == 0:
        return None
    probs = [1 if A[n, API_pre] else 1/q for n in A_neibors]
    p_sum = sum(probs)
    probs = [p/p_sum for p in probs]
    APP_idx = np.random.choice(A_neibors, 1, p = probs).item()
    return apk2node[idx2apk[APP_idx]]

def generate_ABA_random_walks(APP_start, apk2idx, idx2apk, apk2node, node2apk, A, B, p, q, length):
    """
    Generate a ABA random walk of max length "length"
    """
    APP1 = apk2node[APP_start]
    APP_idx = apk2idx[APP_start]
    ser = pd.Series(A[APP_idx].toarray()[0])
    API1 = np.random.choice(ser[ser == 1].index, 1, replace = True).item()
    walk = [APP1, API1]
    while len(walk) < length:
        API2 = API_to_API_ABA(APP1, API1, apk2idx, node2apk, A, B, p, q)
        if not API2:
            return walk
        walk.append(API2)
        APP2 = API_to_APP_ABA(API1, API2, idx2apk, apk2node, A, p, q)
        if not APP2:
            return walk
        walk.append(APP2)
        API1 = APP_to_API_ABA(API2, APP2, apk2idx, node2apk, A, B, p, q)
        if not API1:
            return walk
        walk.append(API1)
        APP1 = APP2
    return walk

# APP1 ---> API1 ---> APP2
def APP_to_API_AA(API, APP, apk2idx, node2apk, A, p, q):
    """
    Generate next API based on the current APP and previous API
    """
    APP_idx = apk2idx[node2apk[APP]]
    ser = pd.Series(A[APP_idx].toarray()[0])
    A_neibors = ser[ser == 1].index
    if len(A_neibors) == 0:
        return None
    probs = [1/p if n == API else 1 for n in A_neibors]
    p_sum = sum(probs)
    probs = [p/p_sum for p in probs]
    API = np.random.choice(A_neibors, 1, p = probs).item()
    return API

def API_to_APP_AA(APP, API, apk2idx, idx2apk, node2apk, apk2node, A, p, q):
    """
    Generate next APP based on the current API and previous APP
    """
    APP_idx = apk2idx[node2apk[APP]]
    ser = pd.Series(A.T[API].toarray()[0])
    A_neibors = ser[ser == 1].index
    if len(A_neibors) == 0:
        return None
    probs = [1/p if n == APP_idx else 1 for n in A_neibors]
    p_sum = sum(probs)
    probs = [p/p_sum for p in probs]
    APP_idx = np.random.choice(A_neibors, 1, p = probs).item()
    return apk2node[idx2apk[APP_idx]]

def generate_AA_random_walks(APP_start, apk2idx, idx2apk, apk2node, node2apk, A, p, q, length):
    """
    Generate a AA random walk of max length "length"
    """
    APP1 = apk2node[APP_start]
    APP_idx = apk2idx[APP_start]
    ser = pd.Series(A[APP_idx].toarray()[0])
    API1 = np.random.choice(ser[ser == 1].index, 1, replace = True).item()
    walk = [APP1, API1]
    while len(walk) < length:
        APP2 = API_to_APP_AA(APP1, API1, apk2idx, idx2apk, node2apk, apk2node, A, p, q)
        if not APP2:
            return walk
        walk.append(APP2)
        API1 = APP_to_API_AA(API1, APP2, apk2idx, node2apk, A, p, q)
        if not API1:
            return walk
        walk.append(API1)
        APP1 = APP2
    return walk

def generate_walks(metapath, apk_names_train, apk2idx_train, idx2apk_train, apk2node_train, node2apk_train, matrix_A_train, matrix_B_train, p, q, k, n):
    """
    Generate k random walks of length n for each APP
    """
    walks = []
    counter = 0
    total = len(apk_names_train)
    for APP_start in apk_names_train:
        print(counter)
        counter += 1
        print("{:.2f}% completed...".format(counter / total * 100))
        for i in range(k):
            if metapath == 'AA':
                walk = generate_AA_random_walks(APP_start, apk2idx_train, idx2apk_train, apk2node_train, \
                                             node2apk_train, matrix_A_train, p, q, m)
            elif metapath == 'ABA':
                walk = generate_ABA_random_walks(APP_start, apk2idx_train, idx2apk_train, apk2node_train, \
                                     node2apk_train, matrix_A_train, matrix_B_train, 2, 2, 100)
            walks.append(walk)
    return walks

def get_class(file):
    """
    Return 1 if it is malware, 0 if benign
    """
    return int('dsc180a-wi20-public' in file)

def get_name(file):
    """
    Return name of the APP
    """
    return '-'.join(file.split('/')[-3:])

def main(targets):
    if 'test' in targets:
        with open('../config/data-params.json') as fh:
            data_cfg = json.load(fh)
        metapath, p, q = data_cfg['metapath'], data_cfg['p'], data_cfg['q']
        matrix_A, matrix_B = data_cfg['matrix_A_position'], data_cfg['matrix_B_position']
        malware_pos, benign_pos = data_cfg['malware_position'], data_cfg['benign_position']
        malware_positions = glob.glob(malware_pos)
        benign_positions = glob.glob(benign_pos)
        decompiled_apks = benign_positions + malware_positions

        train = decompiled_apks
        apk_names_train = [get_name(file) for file in train]
        apk_classes_train = [get_class(file) for file in train]
        apk2idx_train = dict(zip(apk_names_train, range(len(apk_names_train))))
        apk2idx_test = dict(zip(apk_names_test, range(len(apk_names_test))))
        apk2node_train = dict(zip(apk_names_train, range(-len(apk_names_train), 0)))
        node2apk_train = dict(zip(range(-len(apk_names_train), 0), apk_names_train))
        idx2apk_train = dict(zip(apk2idx_train.values(), apk2idx_train.keys()))
        matrix_A_train = scipy.sparse.load_npz(matrix_A)
        matrix_B_train = scipy.sparse.load_npz(matrix_B)
        walks = generate_walks(metapath, apk_names_train, apk2idx_train, idx2apk_train, apk2node_train, node2apk_train, matrix_A_train, matrix_B_train, p, q, k, n)
        walks = [list(map(str, walk)) for walk in walks]
        model = Word2Vec(walks, size=128, window=10, min_count=0, sg=1, workers=8, iter=5)
        model.wv.save_word2vec_format(data_cfg['out'] + '{}_len{}_k{}_w2v.model'.format(metapath, n, k))
        apk2class_train = dict(zip(apk_names_train, apk_classes_train))
        X = [model[str(apk2node_train[apk])] for apk in apk2idx_train if str(apk2node_train[apk]) in model.wv]
        Y = [apk2class_train[apk] for apk in apk2idx_train if str(apk2node_train[apk]) in model.wv]
        X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.2, random_state=42)
        clf = svm.SVC()
        clf.fit(X_train, y_train)
        print(clf.score(X_train, y_train))
        print(clf.score(X_test, y_test))


if __name__ == '__main__':
    targets = sys.argv[1:]
    main(targets)
